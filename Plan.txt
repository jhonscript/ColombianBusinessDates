### **Plan de Desarrollo Detallado: API de Fechas Hábiles en Colombia**

Este documento es un plan de implementación paso a paso para construir la API de cálculo de fechas hábiles, alineado con los requisitos de `Solicitud.txt` y siguiendo una arquitectura limpia y profesional.

---

#### **Fase 1: Configuración del Entorno y Arquitectura del Proyecto**

**Objetivo:** Establecer una base de proyecto limpia, enfocada y escalable.

1.  **Crear Directorio y Proyecto Node.js:**
    *   `mkdir ColombianBusinessDates && cd ColombianBusinessDates`
    *   `npm init -y`

2.  **Instalar TypeScript y Tipos de Node:**
    *   `npm install typescript @types/node ts-node --save-dev`

3.  **Crear Archivo `.gitignore`:**
    *   Crear un archivo `.gitignore` en la raíz para excluir `node_modules`, archivos de entorno y el directorio de compilación.
        ```
        /node_modules
        /dist
        .env
        ```

4.  **Crear y Configurar `tsconfig.json`:**
    *   `npx tsc --init` y modificar el archivo para que coincida con esta configuración:
        ```json
        {
          "compilerOptions": {
            "target": "ES2020",
            "module": "commonjs",
            "outDir": "./dist",
            "rootDir": "./src",
            "strict": true,
            "esModuleInterop": true,
            "skipLibCheck": true,
            "experimentalDecorators": true,
            "emitDecoratorMetadata": true,
            "resolveJsonModule": true
          },
          "include": ["src/**/*"],
          "exclude": ["node_modules", "**/*.test.ts"]
        }
        ```

5.  **Inicializar Proyecto AWS CDK y Estructura:**
    *   El proyecto se inicia con `cdk init app --language typescript`, lo que genera la estructura base para una aplicación CDK.
    *   La estructura principal del proyecto es:
        ```
        .
        ├── bin/              # Punto de entrada de la app CDK
        │   └── cdk-app.ts
        ├── lib/              # Definición de los stacks de CDK
        │   └── cdk-stack.ts
        ├── src/              # Código fuente de la función Lambda (lógica de negocio)
        │   ├── domain/
        │   ├── features/
        │   └── shared/
        ├── cdk.json          # Configuración de CDK
        └── package.json
        ```

6.  **Instalar Dependencias de Producción y Desarrollo:**
    *   **CDK y Lambda:** `npm install aws-cdk-lib constructs @types/aws-lambda @codegenie/serverless-express`
    *   **Lógica de Negocio:** `npm install express date-fns date-fns-tz axios axios-retry zod dotenv pino helmet`
    *   **Desarrollo:** `npm install @types/express @types/jest jest ts-jest esbuild --save-dev`

7.  **Configurar Scripts de NPM:**
    *   Modificar el archivo `package.json` para añadir los scripts de ejecución y prueba:
        ```json
        "scripts": {
          "start": "ts-node src/shared/web/App.ts",
          "test": "jest"
        }
        ```

8.  **Crear Configuración de Jest:**
    *   Crear un archivo `jest.config.js` para que Jest funcione con TypeScript:
        ```javascript
        module.exports = {
          preset: 'ts-jest',
          testEnvironment: 'node',
        };
        ```

---

#### **Fase 2: Definición del Dominio (El Núcleo Abstracto)**

**Objetivo:** Definir los contratos (interfaces) y los errores de negocio que forman el lenguaje de la aplicación.

1.  **Definir Puertos (Interfaces) en `src/domain/ports/`:**
    *   **`IHolidayProvider.ts`**: Define cómo se obtienen los festivos.
        ```typescript
        export interface IHolidayProvider {
          // Se devuelve un Set de strings 'YYYY-MM-DD' para evitar problemas de timezone.
          getHolidays(year: number): Promise<Set<string>>;
        }
        ```
    *   **`IDateCalculator.ts`**: Define la operación central de cálculo.
        ```typescript
        export interface IDateCalculatorParams {
          startDate: Date;
          days?: number;
          hours?: number;
        }

        export interface IDateCalculator {
          calculateBusinessDate(params: IDateCalculatorParams): Promise<Date>;
        }
        ```

2.  **Definir Errores Personalizados en `src/domain/errors.ts`:**
    *   Crear clases de error para un manejo predecible.
        ```typescript
        export class BaseError extends Error {
          public readonly statusCode: number;
          constructor(name: string, statusCode: number, message: string) {
            super(message);
            this.name = name;
            this.statusCode = statusCode;
          }
        }

        export class InvalidInputError extends BaseError {
          constructor(message: string) {
            super("InvalidInputError", 400, message);
          }
        }

        export class HolidayApiError extends BaseError {
          constructor(message: string) {
            super("HolidayApiError", 503, "The holiday service is unavailable.");
          }
        }
        ```

---

#### **Fase 3: Implementación de la Lógica de Negocio**

**Objetivo:** Implementar los contratos del dominio con la lógica de negocio específica de `Solicitud.txt`.

1.  **Implementar `HolidayApiProvider.ts` en `src/shared/infrastructure/services/`:**
    *   Esta clase implementará `IHolidayProvider`.
    *   Tendrá un caché simple en memoria (`private cache: Map<number, Set<string>> = new Map();`) para evitar llamadas repetidas.
    *   El método `getHolidays` usará `axios` para hacer un `GET` a la URL de la API de festivos.
    *   Validará la respuesta de la API usando un esquema de `zod`.
    *   **Diseño Limpio:** La URL de la API se definirá como una constante `private readonly` para facilitar su mantenimiento y evitar "magic strings".

2.  **Implementar `DateCalculator.service.ts` en `src/shared/infrastructure/services/`:**
    *   **Diseño Limpio:** Para asegurar la máxima claridad y mantenibilidad, la implementación seguirá los siguientes principios:
        *   **Extracción de Constantes:** Los números que definen el horario (8, 12, 13, 17) se definirán como constantes `private readonly` con nombres claros (ej. `WORKDAY_START_HOUR`).
        *   **División de Métodos:** La lógica compleja se dividirá en métodos privados con responsabilidades únicas (`_adjustStartDate`, `_addBusinessDays`, `_addBusinessMinutes`). El método público `calculateBusinessDate` actuará como un simple coordinador, haciendo el flujo del programa fácil de seguir.
    *   **Lógica de Cálculo:** El método `_addBusinessMinutes` implementará el robusto enfoque de **"banco de minutos"** para asegurar la precisión en los cálculos.

---

#### **Fase 4: Capa de API, Ruteo y Validación**

**Objetivo:** Exponer la lógica de negocio a través de un endpoint HTTP, validando las entradas y manejando errores.

1.  **Definir Esquema de Validación en `src/features/business-date-calculator/dateCalculator.schema.ts`:**
    *   Usar `zod` para definir un esquema que valide los query params. Se añaden límites máximos para asegurar el rendimiento del algoritmo iterativo.
        ```typescript
        import { z } from 'zod';

        export const calculationSchema = z.object({
          // Limite de ~2 años para evitar bucles excesivos
          days: z.coerce.number().int().min(1).max(730).optional(),
          // Limite de ~1 año hábil en horas para evitar bucles excesivos
          hours: z.coerce.number().int().min(1).max(2080).optional(),
          date: z.string().datetime({ message: "Invalid ISO 8601 date format." }).optional(),
        }).refine(data => data.days || data.hours, {
          message: "At least one of 'days' or 'hours' must be provided.",
        });
        ```

2.  **Implementar Controlador en `dateCalculator.controller.ts`:**
    *   Recibirá la instancia de `IDateCalculator` en su constructor.
    *   Tendrá un método `calculate(req, res, next)` que:
        1.  Valida `req.query` con `calculationSchema.parse()`. Si falla, el `errorHandler` global lo atrapará.
        2.  Determina la `startDate`: `new Date(req.query.date)` si existe, o `new Date()` si no.
        3.  Llama a `this.dateCalculatorService.calculateBusinessDate()` con los parámetros.
        4.  Si tiene éxito, responde con `res.status(200).json({ date: result.toISOString() })`.
        5.  Envuelve todo en un `try...catch` y llama a `next(error)` en caso de fallo.

3.  **Crear Rutas en `src/shared/web/routes/dateCalculator.routes.ts`:**
    *   Crear un `Router` de Express.
    *   Instanciar el controlador (esto se hará en `App.ts` y se inyectará).
    *   Definir la ruta `GET /calculate` y asociarla al método del controlador.

4.  **Configurar `App.ts` (Composition Root) y `lambda.ts` (Punto de Entrada):**
    *   **En `App.ts`:** Se realiza la "composición de objetos":
        *   Se instancian `HolidayApiProvider` y `DateCalculatorService`.
        *   Se inyecta el `HolidayApiProvider` en el `DateCalculatorService`.
        *   Se instancia `DateCalculatorController` y se le inyecta el servicio.
        *   Se configura la aplicación Express con sus middlewares (`helmet`, `pino-http`, etc.) y rutas. La app se exporta sin iniciarla (`app.listen`).
    *   **En `src/lambda.ts`:** Este es el handler (punto de entrada) para AWS Lambda.
        *   Importa la aplicación Express desde `App.ts`.
        *   Utiliza `@codegenie/serverless-express` para envolver la app y exponerla como un handler que API Gateway puede invocar.

5.  **Implementar `errorHandler.ts`:**
    *   Middleware que recibe 4 argumentos `(err, req, res, next)`.
    *   Verifica si el `err` es una instancia de `BaseError` (o de Zod) y formatea la respuesta como `{ error: err.name, message: err.message }` con el `statusCode` correspondiente.
    *   Si no, responde con un error 500 genérico.

---

#### **Fase 5: Pruebas Robustas y Específicas**

**Objetivo:** Garantizar la correcta implementación de la lógica de negocio mediante un conjunto de pruebas basado en los ejemplos de `Solicitud.txt`.

1.  **Pruebas Unitarias (`DateCalculator.service.test.ts`):**
    *   Se debe crear un `MockHolidayProvider` que devuelva un array fijo de festivos para los años de prueba (ej. `['2025-04-17', '2025-04-18']`).
    *   Inyectar este mock en el `DateCalculator.service` para aislar la lógica de la llamada externa.
    *   Implementar todos los casos de prueba de la solicitud para asegurar la correcta implementación de la lógica de negocio, incluyendo casos límite con festivos y precisión de minutos.

2.  **Pruebas de Integración (`dateCalculator.routes.test.ts`):**
    *   Usar `supertest` para hacer peticiones HTTP a la aplicación Express real.
    *   Verificar que una petición sin `days` ni `hours` devuelve un error 400.
    *   **Añadir una suite de pruebas de validación** para asegurar que la API devuelve un error `400 Bad Request` cuando se envían parámetros inválidos, tales como:
        *   Valores negativos.
        *   Valores flotantes.
        *   Combinaciones de parámetros válidos e inválidos.
    *   Implementar al menos un caso de prueba complejo de forma E2E, verificando que la respuesta JSON final en UTC sea la correcta.

---

#### **Fase 6: Creación de Artefactos para la Entrega**

**Objetivo:** Generar todos los archivos necesarios para documentar y desplegar el proyecto.

1.  **Crear `README.md`:**
    *   **Mi Acción:** Usaré mi herramienta `write_file` para crear un archivo `README.md` en la raíz del proyecto.
    *   **Contenido:** Lo llenaré con la estructura definida: instrucciones de instalación (`npm install`), de ejecución (`npm start`), ejemplos de `curl`, y la descripción del endpoint y sus parámetros.

2.  **Definir la Infraestructura como Código:**
    *   El artefacto principal de despliegue es el archivo `lib/cdk-stack.ts`.
    *   Este archivo define la infraestructura en AWS: una API Gateway que se integra con una Función Lambda (Node.js).
    *   CDK se encarga de empaquetar el código de la carpeta `src/` y subirlo a Lambda, junto con la configuración de la API. No se necesita un `Dockerfile`.

3.  **Preparar Repositorio Local:**
    *   **Mi Acción:** Ejecutaré `git init` y `git add .` para preparar un repositorio local con todo el código y los archivos que hemos creado. Haré un commit inicial.

4.  **Subida a GitHub:**
    *   **Tu Acción:** Crearás un repositorio público vacío en tu cuenta de GitHub.
    *   **Mi Guía:** Te proporcionaré los comandos exactos (`git remote add origin ...` y `git push ...`) para que conectes tu repositorio local con el de GitHub y subas todos los archivos.

---

#### **Fase 7: Despliegue con AWS CDK**

**Objetivo:** Publicar la API en AWS y obtener la URL final.

*   **Plataforma:** Se utiliza el AWS Cloud Development Kit (CDK) para definir y desplegar la infraestructura como código, cumpliendo con el "bonus" de la solicitud.

*   **Proceso de Despliegue:**
    1.  **Configurar Credenciales:** Asegurarse de tener las credenciales de AWS configuradas en el entorno local (ej. vía `aws configure`).
    2.  **Instalar Dependencias:** Ejecutar `npm install` en la raíz del proyecto.
    3.  **Bootstrap CDK (si es la primera vez):** Ejecutar `cdk bootstrap` para preparar el entorno de AWS para recibir stacks de CDK.
    4.  **Sintetizar y Desplegar:** Ejecutar el comando `cdk deploy`. CDK compilará el código TypeScript, generará una plantilla de CloudFormation y desplegará todos los recursos (API Gateway, Lambda, etc.) en la cuenta de AWS.
    5.  **Obtener la URL:** Al finalizar el despliegue, CDK mostrará la URL del endpoint de la API Gateway en la sección de "Outputs" de la terminal. Esta es la URL pública de la API.
